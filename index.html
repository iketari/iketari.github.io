<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Canvas - Balls</title>
	<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
			overflow: hidden;
			height: 100%;
		}

		html {
			touch-action: none;
		}

		body {
			display: flex;
			align-items: center;
			justify-content: center;
		}
		canvas {
			cursor: crosshair;
			border: 2px solid black;
			touch-action: chained;
		}
	</style>
</head>
<body>
	<canvas id="canvas" width="0" height="0"></canvas>
	<script>
		var canvas = document.getElementById("canvas")
		var ctx = canvas.getContext("2d")

		var w = 0;
		var h = 0;
		var padding = 15;

		var ball = [];

		var gravity = 0.3;
		var force = 0.2;

		var mouse = {
			d: false,
			x1: 0,
			y1: 0,
			x2: 0,
			y2: 0,
		};

		var acc = {}

		var lastTS = 0;
		var NORM_INT = 50;

		function handleOrientation(event) {
			acc.absolute = event.absolute || 0;
			acc.alpha    = event.alpha || 0;
			acc.beta     = event.beta || 0;
			acc.gamma    = event.gamma || 0;
		};

		window.addEventListener("deviceorientation", throttle(handleOrientation, 500), true);
		handleOrientation({});

		canvas.addEventListener('mousedown', function (e) {
			mouse.d = true
			mouse.x1 = mouse.x2 = e.pageX - canvas.getBoundingClientRect().left
			mouse.y1 = mouse.y2 = e.pageY - canvas.getBoundingClientRect().top
		});

		canvas.addEventListener('mousemove', function (e) {
			if (mouse.d) {
				mouse.x2 = e.pageX - canvas.getBoundingClientRect().left
				mouse.y2 = e.pageY - canvas.getBoundingClientRect().top
			} else {
				mouse.x1 = mouse.x2 = e.pageX - canvas.getBoundingClientRect().left
				mouse.y1 = mouse.y2 = e.pageY - canvas.getBoundingClientRect().top
			}
		});

		canvas.addEventListener('mouseup', function () {
			if (mouse.d) {
				mouse.d = false

				var dx = (mouse.x1 - mouse.x2);
				var dy = (mouse.y1 - mouse.y2);
				var mag = Math.sqrt(dx * dx + dy * dy);
				var r = Math.floor(mag / 5);

				ball.push({
					x: mouse.x1,
					y: mouse.y1,
					r: r > Math.min(w,h) / 4 || r < 20 ? 20 : r,
					vx: dx / mag * -(mag * force),
					vy: dy / mag * -(mag * force),
					b: 0.7,
					color: '#'+Math.floor(Math.random()*16777215).toString(16)
				});

				mouse = {
					d: false,
					x1: 0,
					y1: 0,
					x2: 0,
					y2: 0,
				};
			}
		});

		document.onselectstart = function () {
			return false
		}
		document.oncontextmenu = function () {
			return false
		}

		function _tick (i, timeMuliplier) {
			ball[i].vy += (gravity * timeMuliplier * (Math.cos(toRad(acc.gamma)) * -1 * sign(acc.gamma)));
			ball[i].vx += (gravity * timeMuliplier * (Math.cos(toRad(acc.beta)) * sign(acc.beta)));
			// (Math.cos(toRad(acc.gamma)) * sign(acc.gamma))
			ball[i].x += ball[i].vx;
			ball[i].y += ball[i].vy;

			if (ball[i].x > w - ball[i].r) {
				ball[i].x = w - ball[i].r
				ball[i].vx *= -ball[i].b
			}
			if (ball[i].x < ball[i].r) {
				ball[i].x = ball[i].r
				ball[i].vx *= -ball[i].b
			}
			if (ball[i].y > h - ball[i].r) {
				ball[i].y = h - ball[i].r
				ball[i].vy *= -ball[i].b
			}
			if (ball[i].y < ball[i].r) {
				ball[i].y = ball[i].r
				ball[i].vy *= -ball[i].b
			}
		}

		function _dist (i, j) {
			var dx = ball[i].x - ball[j].x;
			var dy = ball[i].y - ball[j].y;
			return Math.sqrt(dx * dx + dy * dy);
		}

		function update() {
			var ts = Date.now();
			var interval = ts - lastTS;

			var timeMuliplier = interval / NORM_INT;
			lastTS = ts;

			ctx.clearRect(0, 0, w, h);

			ctx.beginPath();
			ctx.moveTo(mouse.x1, mouse.y1);
			ctx.lineTo(mouse.x2, mouse.y2);
			ctx.stroke();
			ctx.closePath();

			if (~location.hash.indexOf('debug')) {
				ctx.fillText('acc:' + [acc.alpha, acc.beta, acc.gamma]. join(' ,'), 20, 20)
				ctx.fillText('' + (Math.cos(toRad(acc.gamma)) * sign(acc.gamma)), 20, 40)
			}

				for (i = 0; i < ball.length; i++) {

				_tick(i, timeMuliplier);

				for (j = i + 1; j < ball.length; j++) {
					var dx = ball[i].x - ball[j].x
					var dy = ball[i].y - ball[j].y
					var dist = _dist(i, j);
					if (Math.abs(dx) + Math.abs(dy) != 0 && dist <= ball[i].r + ball[j].r) {
						var angle = Math.atan2(dy, dx)

						var sp1 = Math.sqrt(ball[i].vx * ball[i].vx + ball[i].vy * ball[i].vy);
						var sp2 = Math.sqrt(ball[j].vx * ball[j].vx + ball[j].vy * ball[j].vy);

						var dir1 = Math.atan2(ball[i].vy, ball[i].vx);
						var dir2 = Math.atan2(ball[j].vy, ball[j].vx);

						var vx1 = sp1 * Math.cos(dir1 - angle);
						var vy1 = sp1 * Math.sin(dir1 - angle);
						var vx2 = sp2 * Math.cos(dir2 - angle);
						var vy2 = sp2 * Math.sin(dir2 - angle);

						var fvx1 = ((ball[i].r - ball[j].r) * vx1 + (2 * ball[j].r) * vx2) / (ball[i].r + ball[j].r);
						var fvx2 = ((2 * ball[i].r) * vx1 + (ball[j].r - ball[i].r) * vx2) / (ball[i].r + ball[j].r);
						var fvy1 = vy1;
						var fvy2 = vy2;

						ball[i].vx = Math.cos(angle) * fvx1 + Math.cos(angle + Math.PI / 2) * fvy1;
						ball[i].vy = Math.sin(angle) * fvx1 + Math.sin(angle + Math.PI / 2) * fvy1;
						ball[j].vx = Math.cos(angle) * fvx2 + Math.cos(angle + Math.PI / 2) * fvy2;
						ball[j].vy = Math.sin(angle) * fvx2 + Math.sin(angle + Math.PI / 2) * fvy2;

						// var attempt = 0;
						// while (_dist(i, j) < ball[i].r + ball[j].r || attempt > 1000) {
						// 	_tick(i, 1);
						// 	_tick(j, 1);
						// 	attempt += 1;
						// }

					}
				}



				ctx.beginPath()
				ctx.arc(ball[i].x, ball[i].y, ball[i].r, 0, Math.PI * 2, false)
				ctx.fillStyle = ball[i].color;
				ctx.fill()
				ctx.closePath()
			}

			requestAnimationFrame(update);
		}

		function init () {
			w = canvas.width = window.innerWidth - padding;
			h = canvas.height = window.innerHeight - padding;

			ball = [];

			var lastTS = Date.now();
			requestAnimationFrame(update);
			// setInterval(update, 1000 / 60)
		}

		init();



		//Helpres
		function throttle(fn, threshhold, scope) {
		  threshhold || (threshhold = 250);
		  var last,
		      deferTimer;
		  return function () {
		    var context = scope || this;

		    var now = +new Date,
		        args = arguments;
		    if (last && now < last + threshhold) {
		      // hold on to it
		      clearTimeout(deferTimer);
		      deferTimer = setTimeout(function () {
		        last = now;
		        fn.apply(context, args);
		      }, threshhold);
		    } else {
		      last = now;
		      fn.apply(context, args);
		    }
		  };
		}

		function toRad(deg) {
			return (deg * Math.PI) / 180;
		}

		function sign(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }
	</script>
</body>
</html>
